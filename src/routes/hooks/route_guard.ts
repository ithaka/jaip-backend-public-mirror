import { FastifyReply, FastifyRequest } from "fastify";
import {
  manage_session,
  get_current_user,
  get_email_from_session,
  get_code_from_session,
} from "../auth/helpers.js";
import { ensure_error } from "../../utils/index.js";
import { SUBDOMAINS } from "../../consts/index.js";

export const route_guard =
  (is_private: boolean) =>
  async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const [session, session_error] = await manage_session(
        request.server,
        request,
      );
      if (session_error) {
        throw session_error;
      }
      const [current_user, user_error] = await get_current_user(
        request.server,
        request,
        get_email_from_session(session),
        get_code_from_session(session),
        false, // Do not include facilities in the user object
      );
      if (user_error) {
        throw user_error;
      }

      // NOTE: Routes generated by, e.g., @fastify/swagger, will have the schema
      // hidden, leaving the tags undefined. Since we don't actually want those routes
      // to have the same auth requirements as the regular private routes, we check
      // for an explicitly false value, rather than just a falsy one. If the route is
      // is not public and we have not found a user, we can return a 401. Otherwise,
      // we can proceed and attach the user and session data even to public routes.
      if (!current_user && is_private) {
        reply.code(401).send();
        return;
      }

      request.session = session;
      if (current_user) {
        request.user = current_user;
        request.is_authenticated_admin =
          SUBDOMAINS.admin.includes(request.subdomain) &&
          request.user.type === "users";
        request.is_authenticated_student =
          SUBDOMAINS.student.includes(request.subdomain) &&
          request.user.type === "facilities";
      }
    } catch (err) {
      const error = ensure_error(err);
      request.server.event_logger.pep_server_error(request, error);
      reply.code(500).send(error.message);
    }
  };
