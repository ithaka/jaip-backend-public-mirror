import { FastifyReply, FastifyRequest } from "fastify";
import {
  manage_session,
  get_current_user,
  get_email_from_session,
  get_code_from_session,
  get_credentials,
} from "../auth/helpers.js";
import { ensure_error, get_subdomain } from "../../utils/index.js";
import { SESSION_ROUTES, SUBDOMAINS } from "../../consts/index.js";

export const route_guard =
  (is_private: boolean) =>
  async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const url = new URL(request.headers.referer || `https://${request.host}`);
      const subdomain = get_subdomain(url.hostname);
      const emails = [];
      const codes = [];
      // If the request is coming from an admin subdomain or a route that requires session data,
      // we will attempt to get session data. Otherwise, we will attempt to get site codes from the IAC service based on the request IP.
      if (
        SUBDOMAINS.admin.includes(subdomain) ||
        SESSION_ROUTES.some((route) =>
          (request.routeOptions.url || "").startsWith(route),
        )
      ) {
        const [session, session_error] = await manage_session(
          request.server,
          request,
        );
        if (session_error) {
          throw session_error;
        }
        request.session = session;

        emails.push(...get_email_from_session(session));
        codes.push(...get_code_from_session(session));
      } else {
        const [iac_codes, iac_error] = await get_credentials(
          request.server,
          request,
        );
        if (iac_error) {
          throw iac_error;
        }
        codes.push(...iac_codes);
      }

      // Once we have any possible emails or sitecodes, we can get the JAIP user
      // associated with that session or IP address.
      const [current_user, user_error] = await get_current_user(
        request.server,
        request,
        emails,
        codes,
        false, // Do not include facilities in the user object
      );
      if (user_error) {
        throw user_error;
      }

      // NOTE: Routes generated by, e.g., @fastify/swagger, will have the schema
      // hidden, leaving the tags undefined. Since we don't actually want those routes
      // to have the same auth requirements as the regular private routes, we check
      // for an explicitly false value, rather than just a falsy one. If the route is
      // is not public and we have not found a user, we can return a 401. Otherwise,
      // we can proceed and attach the user and session data even to public routes.
      if (!current_user && is_private) {
        reply.code(401).send();
        return;
      }

      if (current_user) {
        // Attach User object to the request object for use in route handlers
        request.user = current_user;

        // Set flags for whether the user is an authenticated admin or student based on their subdomain and account type.
        // This will be used in route handlers and hooks to determine access to certain features.
        request.is_authenticated_admin =
          SUBDOMAINS.admin.includes(request.subdomain) &&
          request.user.type === "users";
        request.is_authenticated_student =
          SUBDOMAINS.student.includes(request.subdomain) &&
          request.user.type === "facilities";
      }
    } catch (err) {
      const error = ensure_error(err);
      request.server.event_logger.pep_server_error(request, error);
      reply.code(500).send(error.message);
    }
  };
