import Fastify, { RequirementsSchema } from "fastify";
import fastify_swagger from "@fastify/swagger";
import fastify_swagger_ui from "@fastify/swagger-ui";
import fastify_cookie from "@fastify/cookie";
import fastify_cors from "@fastify/cors";

import { SWAGGER_OPTS, VALIDATED_METHODS } from "./consts";

import plugins from "./plugins";

import "dotenv/config";
import { requirements_guard, route_guard, validate } from "./routes/hooks";
import { SWAGGER_TAGS } from "./consts";
import { add_subdomain } from "./routes/hooks/add_subdomain";
import { RouteSettings } from "./types/routes";

// This modification allows us to extend the fastify schema with an
declare module "fastify" {
  interface RequirementsSchema extends FastifySchema {
    requires?: {
      any?: {
        grouped?: {
          all?: string[];
          any?: string[];
        };
        ungrouped?: string[];
      };
    };
  }
}

function build(opts = {}, route_settings: RouteSettings[]) {
  const app = Fastify(opts);

  app.register(fastify_cors, {
    origin: [/\.jstor\.org$/, /\.cirrostratus\.org$/],
  })

  app.addHook("onRoute", (routeOptions) => {
    app.log.info(`Adding route: ${routeOptions.url}`);

    // Add the subdomain to the request for all routes
    routeOptions.preHandler = [add_subdomain];

    // Check the schema for public swagger tags
    const is_public =
      routeOptions.schema?.tags?.includes(SWAGGER_TAGS.public) ||
      routeOptions.schema?.tags?.includes(SWAGGER_TAGS.healthcheck);

    // If the route is not public, add the route guard
    // NOTE: Routes generated by, e.g., @fastify/swagger, will have the schema
    // hidden, leaving the tags undefined. Since we don't actually want those routes
    // to have the same auth requirements as the regular private routes, we check
    // for an explicitly false value, rather than just a falsy one.
    if (is_public === false) {
      app.log.info(`Adding route guard to ${routeOptions.url}`);
      routeOptions.preHandler.push(route_guard);
    }

    // NOTE: This handler takes advantage of the user object added in the route_guard,
    // and must therefore be added after the route guard.
    const schema = routeOptions.schema as RequirementsSchema;
    const requirements =
      schema.requires?.any?.grouped?.any ||
      schema.requires?.any?.grouped?.all ||
      schema.requires?.any?.ungrouped;
    if (requirements && requirements.length) {
      app.log.info(`Adding requirements guard to ${routeOptions.url}`);
      routeOptions.preHandler.push(requirements_guard);
    }

    const methods = Array.isArray(routeOptions.method)
      ? routeOptions.method
      : [routeOptions.method];
    for (const method of methods) {
      if (VALIDATED_METHODS.includes(method)) {
        app.log.info(`Adding validation to ${routeOptions.url}`);
        routeOptions.preValidation = [validate];
      }
    }
  });

  // Swagger
  app.register(fastify_swagger, SWAGGER_OPTS);
  app.register(fastify_swagger_ui, {
    routePrefix: "/docs",
    uiConfig: {
      docExpansion: "list",
      deepLinking: false,
    },
    staticCSP: false,
  });

  // Fastify cookie movies cookies to their own section of the Response object
  app.register(fastify_cookie);

  // Plugins
  for (const { plugin, options } of Object.values(plugins)) {
    app.register(plugin, options);
  }

  // Routes
  for (const { routes, options } of route_settings) {
    app.register(routes, {
      ...opts,
      ...options,
    });
  }

  return app;
}

export default build;
